<!--
@component Globe
@tags organism, 3d, visualization, interactive, map
-->

<script lang="ts">
	import { browser } from '$app/environment';
	import { mq } from '@layerd/ui';
	import { untrack } from 'svelte';
	import * as THREE from 'three';
	import {
		type GlobeProps,
		type Location,
		type Port,
		type Arc,
		type Ring,
		type Label,
		createDefaultConfig,
		avoidLabelCollisions,
		createAutoPlay,
		markerSVG,
		mergeConfigs
	} from '@layerd/ui';

	let {
		locations = $bindable([]),
		ports = $bindable([]),
		class: className = '',
		// All other props are collected into restProps to be merged into the config
		...restProps
	}: GlobeProps = $props();

	// Dynamic import type for Globe
	type GlobeInstance = any;

	// ============================================================================
	// State Management (Svelte 5 Runes)
	// ============================================================================

	let globeContainer: HTMLDivElement | undefined = $state();
	let globeInstance: GlobeInstance | null = $state(null);
	let currentIndex = $state(0);
	let previousLocation: Location | null = $state(null);
	let activeArcs: Arc[] = $state([]);
	let activeRings: Ring[] = $state([]);
	let windowDimensions = $state({
		width: browser ? window.innerWidth : 1920,
		height: browser ? window.innerHeight : 1080
	});

	// Store marker elements for class toggling
	let markerElements = $state<Map<string, HTMLElement>>(new Map());

	// Store fetched data
	let fetchedLocations = $state<Location[]>([]);
	let fetchedPorts = $state<Port[]>([]);
	let isLoadingData = $state(false);

	// Create a reactive, merged configuration
	const mergedConfig = $derived(
		mergeConfigs(
			createDefaultConfig(windowDimensions.width, windowDimensions.height),
			restProps.config, // The main config object prop
			restProps // Individual objects like `data`, `arcs`, etc.
		)
	);

	// Get locations and ports from data config or direct props
	const locationsSource = $derived(mergedConfig.data?.locations ?? locations);
	const portsSource = $derived(mergedConfig.data?.ports ?? ports);

	// Resolve locations and ports (fetch if URL, use directly if array)
	const effectiveLocations = $derived(
		typeof locationsSource === 'string' ? fetchedLocations : (locationsSource as Location[]) || []
	);
	const effectivePorts = $derived(
		typeof portsSource === 'string' ? fetchedPorts : (portsSource as Port[]) || []
	);

	// Current location and ports
	const currentLocation = $derived(effectiveLocations[currentIndex] || null);
	const currentPorts = $derived(
		currentLocation
			? effectivePorts.filter((port) => port.location === currentLocation.location)
			: []
	);

	// ============================================================================
	// Helper Functions
	// ============================================================================

	// Attachment function for globe container
	function attachGlobeContainer(element: HTMLElement) {
		globeContainer = element as HTMLDivElement;
		return () => {
			globeContainer = undefined;
		};
	}

	// Create attachment for marker elements
	function createMarkerAttachment(lat: number, lng: number) {
		const key = `${lat},${lng}`;
		return (element: HTMLElement) => {
			markerElements.set(key, element);
			return () => {
				markerElements.delete(key);
			};
		};
	}

	function changeLocation(newIndex: number) {
		const total = effectiveLocations.length;
		if (total === 0) return;
		const normalizedIndex = (newIndex + total) % total;
		console.log(
			`🎯 changeLocation() called: newIndex=${newIndex}, normalized=${normalizedIndex}, current=${currentIndex}`
		);
		currentIndex = normalizedIndex;
	}

	function emitArc(startLocation: Location, endLocation: Location) {
		if (!startLocation || !endLocation || !globeInstance) return;

		const startLat = parseFloat(String(startLocation.lat));
		const startLng = parseFloat(String(startLocation.lng));
		const endLat = parseFloat(String(endLocation.lat));
		const endLng = parseFloat(String(endLocation.lng));

		const globe = globeInstance;
		// Use untrack to read config without creating dependency
		const cfg = untrack(() => mergedConfig);
		const FLIGHT_TIME = cfg.arcs?.flightTime ?? 2000;
		const ARC_REL_LEN = cfg.arcs?.relativeLength ?? 0.4;

		console.log(
			`🚀 EMITTING ARC: ${startLocation.location} (${startLat}, ${startLng}) → ${endLocation.location} (${endLat}, ${endLng})`
		);

		// Create and add the arc
		const arc: Arc = {
			startLat,
			startLng,
			endLat,
			endLng,
			color: cfg.arcs?.color ?? 'rgba(255, 255, 255, 1)'
		};

		// Add arc to active arcs array
		const newArcs = [...activeArcs, arc];
		untrack(() => {
			activeArcs = newArcs;
		});
		globe.arcsData(newArcs);
		console.log(`   ✈️  Arc added, total arcs: ${newArcs.length}`);

		// Remove arc after animation completes
		setTimeout(() => {
			untrack(() => {
				activeArcs = activeArcs.filter((d) => d !== arc);
			});
			globe.arcsData(activeArcs);
			console.log(
				`   ✈️  Arc removed (${startLocation.location} → ${endLocation.location}), remaining arcs: ${activeArcs.length}`
			);
		}, FLIGHT_TIME * 2);

		// Add start location rings
		const startRing: Ring = { lat: startLat, lng: startLng };
		const newStartRings = [...activeRings, startRing];
		untrack(() => {
			activeRings = newStartRings;
		});
		globe.ringsData(newStartRings);
		console.log(
			`   � START ring added at ${startLocation.location} (${startLat}, ${startLng}), total rings: ${newStartRings.length}`
		);

		// Remove start rings after partial animation - FILTER BY VALUES, NOT REFERENCE
		setTimeout(() => {
			untrack(() => {
				activeRings = activeRings.filter((r) => !(r.lat === startLat && r.lng === startLng));
			});
			globe.ringsData(activeRings);
			console.log(
				`   � START ring removed from ${startLocation.location} (${startLat}, ${startLng}), remaining rings: ${activeRings.length}`
			);
		}, FLIGHT_TIME * ARC_REL_LEN);

		// Add end location rings with delay
		setTimeout(() => {
			const endRing: Ring = { lat: endLat, lng: endLng };
			const newEndRings = [...activeRings, endRing];
			untrack(() => {
				activeRings = newEndRings;
			});
			globe.ringsData(newEndRings);
			console.log(
				`   � END ring added at ${endLocation.location} (${endLat}, ${endLng}), total rings: ${newEndRings.length}`
			);

			// Remove end rings after partial animation - FILTER BY VALUES, NOT REFERENCE
			setTimeout(() => {
				untrack(() => {
					activeRings = activeRings.filter((r) => !(r.lat === endLat && r.lng === endLng));
				});
				globe.ringsData(activeRings);
				console.log(
					`   � END ring removed from ${endLocation.location} (${endLat}, ${endLng}), remaining rings: ${activeRings.length}`
				);

				// After end rings are removed, THEN set the final ring
				setTimeout(() => {
					globe.ringsData([{ lat: endLat, lng: endLng }]);
					console.log(
						`   ✅ FINAL ring set at ${endLocation.location} (${endLat}, ${endLng}) - Arc animation complete`
					);
				}, 100);
			}, FLIGHT_TIME * ARC_REL_LEN);
		}, FLIGHT_TIME);
	}

	function handleKeyboard(event: KeyboardEvent) {
		if (event.key === 'ArrowLeft') {
			changeLocation(currentIndex - 1);
			event.preventDefault();
		} else if (event.key === 'ArrowRight') {
			changeLocation(currentIndex + 1);
			event.preventDefault();
		}
	}

	// ============================================================================
	// Effects (Svelte 5 $effect)
	// ============================================================================

	// Fetch data when URLs are provided
	$effect(() => {
		if (!browser) return;

		const locSrc = locationsSource;
		const portSrc = portsSource;

		const needsFetch = typeof locSrc === 'string' || typeof portSrc === 'string';
		if (!needsFetch) return;

		isLoadingData = true;
		const promises: Promise<void>[] = [];

		// Fetch locations if URL is provided
		if (typeof locSrc === 'string') {
			console.log('🌍 Fetching locations from:', locSrc);
			promises.push(
				fetch(locSrc)
					.then((res) => res.json())
					.then((data) => {
						fetchedLocations = data;
						console.log('✅ Locations loaded:', data.length, 'items');
					})
					.catch((err) => {
						console.error('❌ Failed to fetch locations:', err);
					})
			);
		}

		// Fetch ports if URL is provided
		if (typeof portSrc === 'string') {
			console.log('🌍 Fetching ports from:', portSrc);
			promises.push(
				fetch(portSrc)
					.then((res) => res.json())
					.then((data) => {
						fetchedPorts = data;
						console.log('✅ Ports loaded:', data.length, 'items');
					})
					.catch((err) => {
						console.error('❌ Failed to fetch ports:', err);
					})
			);
		}

		// Wait for all fetches to complete
		Promise.all(promises).finally(() => {
			isLoadingData = false;
			console.log('🎉 Data loading complete');
		});
	});

	// Update globe rings and view when current location changes
	$effect(() => {
		const globe = globeInstance;
		const location = currentLocation;
		const prevLoc = untrack(() => previousLocation);
		// Use untrack to read config without creating dependency
		const cfg = untrack(() => mergedConfig);

		if (!globe || !location) return;

		console.log(
			`📍 LOCATION EFFECT TRIGGERED - Current: ${location.location}, Previous: ${prevLoc?.location ?? 'null'}`
		);

		// First time initialization - single ring animation
		if (!prevLoc) {
			const ring: Ring = {
				lat: parseFloat(String(location.lat)),
				lng: parseFloat(String(location.lng))
			};

			console.log(`   🔰 FIRST LOAD - Setting initial ring at ${location.location}`);

			// Clear any existing rings immediately on first load
			globe.ringsData([]);

			setTimeout(() => {
				globe.ringsData([ring]);

				// Remove ring after animation
				setTimeout(
					() => {
						globe.ringsData([]);
					},
					(cfg.arcs?.flightTime ?? 2000) * (cfg.arcs?.relativeLength ?? 0.4)
				);
			}, 100);

			// Update previous location using untrack to avoid triggering this effect
			untrack(() => {
				previousLocation = location;
			});

			// Update globe view
			globe.pointOfView(
				{
					lat: parseFloat(String(location.lat)) - (cfg.globe?.latitude ?? 0),
					lng: parseFloat(String(location.lng)),
					altitude: cfg.globe?.altitude ?? 0.25
				},
				cfg.animation?.duration ?? 1000
			);

			return;
		}

		// Location change - emit arc and ring animations
		// Compare by actual values, not proxy references
		const locationChanged =
			prevLoc.location !== location.location ||
			prevLoc.lat !== location.lat ||
			prevLoc.lng !== location.lng;

		console.log(`   🔄 Location changed: ${locationChanged}`);
		console.log(`      From: ${prevLoc.location} (${prevLoc.lat}, ${prevLoc.lng})`);
		console.log(`      To: ${location.location} (${location.lat}, ${location.lng})`);

		if (locationChanged) {
			console.log(`   ⚡ CALLING emitArc()`);
			// DO NOT clear rings here - let emitArc handle everything
			emitArc(prevLoc, location);

			// Update previous location using untrack to avoid triggering this effect
			untrack(() => {
				previousLocation = location;
			});

			// Update globe view
			globe.pointOfView(
				{
					lat: parseFloat(String(location.lat)) - (cfg.globe?.latitude ?? 0),
					lng: parseFloat(String(location.lng)),
					altitude: cfg.globe?.altitude ?? 0.25
				},
				cfg.animation?.duration ?? 1000
			);
		} else {
			console.log(`   ⏭️  SKIPPED - No actual location change detected`);
		}
	});

	// Update labels when current ports change
	$effect(() => {
		const globe = globeInstance;
		const ports = currentPorts;
		// Use untrack to read config without creating dependency
		const cfg = untrack(() => mergedConfig);

		if (!globe || !ports.length) {
			if (globe) globe.labelsData([]);
			return;
		}

		// Clear existing labels immediately
		globe.labelsData([]);

		// Add delay to match arc animation timing
		setTimeout(
			() => {
				// Create initial label data
				const labelData: Label[] = ports.map((port) => ({
					lat: parseFloat(String(port.lat)),
					lng: parseFloat(String(port.lng)),
					label: port.city || 'Unknown Port',
					size: cfg.labels?.size ?? 0.5,
					dotRadius: cfg.labels?.dotRadius ?? 0.2,
					orientation: 'bottom'
				}));

				// Apply collision detection
				const adjustedLabels = avoidLabelCollisions(labelData);
				globe.labelsData(adjustedLabels);
			},
			(cfg.arcs?.flightTime ?? 2000) + 500
		);
	});

	// Update markers when current location changes
	$effect(() => {
		if (!browser) return;

		const loc = currentLocation;
		if (!loc) return;

		const currentLat = parseFloat(String(loc.lat));
		const currentLng = parseFloat(String(loc.lng));

		setTimeout(() => {
			// Use tracked marker elements instead of querySelectorAll
			markerElements.forEach((markerEl, key) => {
				const marker = markerEl.querySelector('.svg-marker');
				if (!marker) return;

				const [lat, lng] = key.split(',').map(Number);
				const isActive = lat === currentLat && lng === currentLng;

				marker.classList.toggle('active', isActive);
			});
		}, 500);
	});

	// ============================================================================
	// Globe Initialization (Svelte 5 $effect - HMR-friendly)
	// ============================================================================

	// Initialize globe when container is ready
	$effect(() => {
		if (!browser || !globeContainer || effectiveLocations.length === 0) return;

		let globe: GlobeInstance | null = null;
		let isDestroyed = false;

		// Dynamically import and initialize Globe.gl only in browser
		(async () => {
			try {
				const GlobeGL = await import('globe.gl');
				const Globe = GlobeGL.default;

				// Check if component was destroyed during async import
				if (isDestroyed) return;

				const cfg = untrack(() => mergedConfig);
				const altitude = cfg.globe?.altitude ?? 0.5;

				globe = new Globe(globeContainer)
					.backgroundColor('rgba(0,0,0,0)')
					.globeOffset([cfg.globe?.left ?? 0, cfg.globe?.top ?? 0])
					.pointOfView({ lat: 0, lng: 0, altitude })
					.showAtmosphere(cfg.atmosphere?.show ?? true)
					.atmosphereColor(cfg.atmosphere?.color ?? 'lightskyblue')
					.atmosphereAltitude(cfg.atmosphere?.altitude ?? 0.15);

				// Set a single, moderately bright ambient light to make rings/labels visible
				const ambientLight = new THREE.AmbientLight(0xffffff, 2);
				globe.lights([ambientLight]);
				console.log('💡 Set a moderate ambient light for effects.');

				// Disable bloom/glow post-processing effect
				const composer = globe.postProcessingComposer();
				if (composer && composer.passes) {
					const bloomPass = composer.passes.find(
						(pass: any) => pass.name === 'UnrealBloomPass' || pass.name === 'BloomPass'
					);
					if (bloomPass) {
						bloomPass.enabled = false;
						console.log('✅ Disabled bloom pass.');
					}
				}

				// COUNTRY OUTLINES
				if (cfg.data?.polygons) {
					fetch(cfg.data.polygons)
						.then((res) => res.json())
						.then((data) => {
							if (isDestroyed || !globe) return;

							const capColor = cfg.polygon?.capColor ?? '#444444';
							const sideColor = cfg.polygon?.sideColor ?? '#444444';
							const strokeColor = cfg.polygon?.strokeColor ?? '#ffffff';

							// Resolve color to string if it's a function
							const resolvedCapColor = typeof capColor === 'function' ? capColor({}) : capColor;
							const resolvedSideColor = typeof sideColor === 'function' ? sideColor({}) : sideColor;
							const resolvedStrokeColor =
								typeof strokeColor === 'function' ? strokeColor : strokeColor;

							globe
								.polygonsData(data.features || data)
								.polygonCapMaterial(
									new THREE.MeshBasicMaterial({
										color: resolvedCapColor,
										transparent: false,
										side: THREE.DoubleSide
									})
								)
								.polygonSideMaterial(
									new THREE.MeshBasicMaterial({
										color: resolvedSideColor,
										transparent: false,
										side: THREE.DoubleSide
									})
								)
								.polygonStrokeColor(() => resolvedStrokeColor)
								.polygonAltitude(cfg.polygon?.altitude ?? 0.005)
								.polygonsTransitionDuration(cfg.polygon?.transitionDuration ?? 0);
						})
						.catch((err) => console.error('Failed to load polygon data:', err));
				}

				globe
					// RINGS - Above countries
					.ringLat((d: any) => d.lat)
					.ringLng((d: any) => d.lng)
					.ringAltitude(cfg.rings?.altitude ?? 0.002)
					.ringColor(() => (t: number) => `rgba(255,255,255,${1 - t})`)
					.ringMaxRadius(cfg.rings?.maxRadius ?? 4)
					.ringPropagationSpeed(cfg.rings?.propagationSpeed ?? 4)
					.ringResolution(64)
					.ringsData([])
					.ringRepeatPeriod(
						((cfg.arcs?.flightTime ?? 2000) * (cfg.arcs?.relativeLength ?? 0.4)) /
							(cfg.arcs?.numRings ?? 5)
					)
					// ARCS - Above rings
					.arcColor('color')
					.arcStroke(cfg.arcs?.stroke ?? 0.2)
					.arcDashLength(cfg.arcs?.dashLength ?? 0.6)
					.arcDashGap(cfg.arcs?.dashGap ?? 2)
					.arcDashInitialGap(cfg.arcs?.dashInitialGap ?? 1)
					.arcDashAnimateTime(cfg.arcs?.flightTime ?? 2000)
					.arcAltitude(cfg.arcs?.altitude ?? null)
					.arcAltitudeAutoScale(cfg.arcs?.altitudeAutoscale ?? 0.3)
					.arcStartAltitude(cfg.arcs?.startAltitude ?? 0.003)
					.arcEndAltitude(cfg.arcs?.endAltitude ?? 0.003)
					.arcsTransitionDuration(0)
					.arcLabel((d: any) => `${d.port || 'Port'} - ${d.city || 'Unknown'}`)
					// POINTS - Solid blue dots (base layer)
					.pointsData(effectiveLocations)
					.pointAltitude(() => cfg.points?.altitude ?? 0.003)
					.pointColor(() => cfg.points?.color ?? '#0066ff')
					.pointRadius(0.25)
					// LABELS - Floating above everything else
					.labelColor(() => cfg.labels?.textColor ?? 'rgba(255, 255, 255, 1)')
					.labelDotOrientation((d: any) => d.orientation)
					.labelDotRadius(() => cfg.labels?.dotRadius ?? 0.25)
					.labelSize(() => cfg.labels?.size ?? 1)
					.labelText('label')
					.labelLabel((d: any) => `<div>${d.label}</div>`)
					.labelAltitude(cfg.labels?.altitude ?? 0.015)
					.labelResolution(120)
					// HTML - Floating above everything
					.htmlElementsData(effectiveLocations)
					.htmlElement((d: any) => {
						const el = document.createElement('div');
						el.innerHTML = markerSVG;
						el.dataset.lat = String(d.lat);
						el.dataset.lng = String(d.lng);

						// Apply attachment for lifecycle tracking
						const markerKey = createMarkerAttachment(
							parseFloat(String(d.lat)),
							parseFloat(String(d.lng))
						);
						markerKey(el);

						el.style.pointerEvents = 'auto';
						el.onclick = () => {
							const idx = effectiveLocations.findIndex(
								(loc) =>
									parseFloat(String(loc.lat)) === parseFloat(String(d.lat)) &&
									parseFloat(String(loc.lng)) === parseFloat(String(d.lng))
							);
							if (idx >= 0) {
								changeLocation(idx);
							}
						};
						return el;
					})
					.htmlLat((d: any) => d.lat)
					.htmlLng((d: any) => d.lng)
					.htmlAltitude(cfg.html?.altitude ?? 0.02)
					// FIRST LOAD
					.onGlobeReady(() => {
						if (isDestroyed) return;

						const scene = globe!.scene();

						// Make ONLY the globe sphere a solid, unlit black
						scene.traverse((object: any) => {
							if (object.type === 'Mesh' && object.geometry?.type === 'SphereGeometry') {
								object.material = new THREE.MeshBasicMaterial({
									color: 0x000000 // Solid black
								});
								console.log('✅ Converted globe sphere to solid black MeshBasicMaterial.');
							}
						});

						if (effectiveLocations.length > 0) {
							const firstLocation = effectiveLocations[0];
							globe!.ringsData([
								{
									lat: parseFloat(String(firstLocation.lat)),
									lng: parseFloat(String(firstLocation.lng))
								}
							]);
							currentIndex = 0;

							// Setup auto-play
							if (cfg.autoplay?.enabled && globeContainer) {
								const interactionElements = [globeContainer, document];
								createAutoPlay(
									cfg.autoplay,
									() => changeLocation(currentIndex + 1),
									interactionElements
								)(true);
							}
						}
					});

				globe.controls().enableZoom = false;
				globeInstance = globe;
			} catch (error) {
				console.error('Failed to initialize Globe.gl:', error);
				// Display user-friendly error message
				if (globeContainer && !isDestroyed) {
					globeContainer.innerHTML = `
						<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: white; text-align: center; padding: 20px;">
							<div>
								<h3 style="margin-bottom: 10px;">Unable to load 3D Globe</h3>
								<p style="opacity: 0.7; font-size: 14px;">WebGL context error. Please try:</p>
								<ul style="list-style: none; padding: 0; opacity: 0.7; font-size: 14px;">
									<li>• Refresh the page (Ctrl+Shift+R)</li>
									<li>• Close other browser tabs</li>
									<li>• Restart your browser</li>
								</ul>
							</div>
						</div>
					`;
				}
			}
		})();

		// Cleanup function that runs when effect re-runs or component unmounts
		return () => {
			isDestroyed = true;
			if (globe) {
				globe._destructor();
			}
			globeInstance = null;
		};
	});

	// Window resize handler
	$effect(() => {
		if (!browser) return;

		const handleResize = () => {
			windowDimensions = {
				width: window.innerWidth,
				height: window.innerHeight
			};

			if (globeInstance) {
				// Use untrack to read config without creating dependency
				const cfg = untrack(() => mergedConfig);
				globeInstance
					.width(window.innerWidth)
					.height(window.innerHeight)
					.globeOffset([cfg.globe?.left ?? 0, cfg.globe?.top ?? 0])
					.pointOfView({ lat: 0, lng: 0, altitude: cfg.globe?.altitude ?? 0.5 }, 1000);
			}
		};

		window.addEventListener('resize', handleResize);
		return () => window.removeEventListener('resize', handleResize);
	});

	// Keyboard navigation
	$effect(() => {
		if (!browser) return;

		window.addEventListener('keydown', handleKeyboard);
		return () => window.removeEventListener('keydown', handleKeyboard);
	});
</script>

<div
	class="globe-container {className}"
	{@attach attachGlobeContainer}
></div>

<style>
	.globe-container {
		position: relative;
		width: 100%;
		height: 100%;
	}

	:global(.svg-marker) {
		width: 40px;
		height: 40px;
		cursor: pointer;
		transition: all 0.3s ease;
	}

	:global(.svg-marker .stroke) {
		stroke: white;
		transition: stroke 0.3s ease;
	}

	:global(.svg-marker .bg) {
		fill: white;
		transition: fill 0.3s ease;
	}

	:global(.svg-marker .fg) {
		fill: #333;
		transition: fill 0.3s ease;
	}

	:global(.svg-marker.active) {
		transform: scale(1.2);
	}

	:global(.svg-marker.active .stroke) {
		stroke: lime;
	}

	:global(.svg-marker.active .bg) {
		fill: lime;
	}

	:global(.svg-marker:hover) {
		transform: scale(1.1);
	}
</style>
